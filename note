  kubectl create cm morevar --from-literal=mysql=passwodofme --from-literal=var3=vzg --dry-run=client -o yaml

  kubectl create cm mycm --from-file=variables --dry-run=client -o yaml > a.yml
  
  
  envFrom:
      - secretRef:
          name: mysecret
  
  envFrom:
      - configMapRef:
          name: filename
          
          
          
          
kubectl label nodes node-1 size=Large

apiVersion: v1
kind: Pod
metadata:
 name: myapp-pod
spec:
 containers:
 - name: data-processor
   image: data-processor
 nodeSelector:
  size: Large
          
 
Taints and Tolearations:


taint: is the command to apply taints in the nodes
nodes: are set of worker nodes
nodename: is the name of the specific worker node, on which taint has to be applied, it has a key-value pair
key-value pair: it is used to specify which application type in the pod will this node may be attached
taint-effect: This is used to define how the pod will be treated if they are not tolerant of the taint.

The effects are as below;

    NoSchedule — Pods will not be schedule on the nodes
    PreferNoSchedule — The system will try to avoid placing a pod on the node, but it’s not guaranteed
    NoExecute — New pods will not be scheduled on the node and existing pods on the node if any will be evicted if they do not tolerate the taint
  












Create a taint on node01 with key of spray, value of mortein and effect of NoSchedule


kubectl taint nodes node1 app=blue:NoSchedule















Requests define the minimum amount of resources that containers need.

If you think that your app requires at least 256MB of memory to operate, this is the request value.

The application can use more than 256MB, but Kubernetes guarantees a minimum of 256MB to the container.

On the other hand, limits define the max amount of resources that the container can consume.

Your application might require at least 256MB of memory, but you might want to be sure that it doesn't consume more than 1GB of memory.

That's your limit.

Notice how your application has 256MB of memory guaranteed, but it can grow up until 1GB of memory.

After that, it is stopped or throttled by Kubernetes


kubectl autoscale rs web --max=5

 kubectl autoscale deploy demo --cpu-percent=50  --min=1 --max=5 --dry-run=client -o yaml
 
 kubectl run v --image=nginx --requests='cpu=50m,memory=50Mi' --limits='cpu=50m,memory=50Mi'  --dry-run=client -o yaml > b.yml
 
  kubectl autoscale deploy demo --cpu-percent=50  --min=1 --max=5 --dry-run=client -o yaml
 
 stress --cpu 3
 
 apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: myapp
  name: myapp
spec:
  replicas: 2
  selector:
    matchLabels:
      app: myapp
  strategy: {}
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - image: httpd
        name: httpd
        resources:
          limits:
            cpu: 500m
          requests:
            cpu: 200m

cpuutilazation:20
